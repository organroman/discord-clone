{"version":3,"sources":["../../src/hooks/useAudioPlayback.ts","../../src/hooks/internal/useResizeObserver.ts","../../src/hooks/internal/useObservableState.ts","../../src/context/layout-context.ts","../../src/context/participant-context.ts","../../src/context/track-context.ts","../../src/context/room-context.ts","../../src/hooks/useClearPinButton.ts","../../src/mergeProps.ts","../../src/hooks/useConnectionQualityIndicator.ts","../../src/hooks/useConnectionStatus.ts","../../src/hooks/useDataChannel.ts","../../src/hooks/useDisconnectButton.ts","../../src/hooks/useFacingMode.ts","../../src/hooks/useFocusToggle.ts","../../src/hooks/useGridLayout.ts","../../src/hooks/useIsMuted.ts","../../src/hooks/useIsSpeaking.ts","../../src/hooks/useLiveKitRoom.ts","../../src/hooks/useLocalParticipant.ts","../../src/hooks/useLocalParticipantPermissions.ts","../../src/hooks/useMediaDeviceSelect.ts","../../src/hooks/useMediaDevices.ts","../../src/hooks/useMediaTrackBySourceOrName.ts","../../src/utils.ts","../../src/hooks/useMediaTrack.ts","../../src/hooks/useMediaTrackByName.ts","../../src/hooks/usePagination.ts","../../src/hooks/useVisualStableUpdate.ts","../../src/hooks/useParticipantInfo.ts","../../src/hooks/useParticipantPermissions.ts","../../src/hooks/useParticipantTile.ts","../../src/hooks/useRemoteParticipants.ts","../../src/hooks/useParticipants.ts","../../src/hooks/usePinnedTracks.ts","../../src/hooks/useRemoteParticipant.ts","../../src/hooks/useRoomInfo.ts","../../src/hooks/useSortedParticipants.ts","../../src/hooks/useSpeakingParticipants.ts","../../src/hooks/useStartAudio.ts","../../src/hooks/useSwipe.ts","../../src/hooks/useChatToggle.ts","../../src/hooks/useToken.ts","../../src/hooks/useTrackMutedIndicator.ts","../../src/hooks/useTrackToggle.ts","../../src/hooks/useTracks.ts"],"sourcesContent":["import type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useObservableState } from './internal';\nimport { roomAudioPlaybackAllowedObservable } from '@livekit/components-core';\nimport { useEnsureRoom } from '../context';\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useAudioPlayback` hook returns an object with a boolean `canPlayAudio` flag that indicates whether audio\n * playback is allowed in the current context, as well as a `startAudio` function that can be called in a button\n * `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useAudioPlayback(room?: Room): {\n  canPlayAudio: boolean;\n  startAudio: () => Promise<void>;\n} {\n  const roomEnsured = useEnsureRoom(room);\n  const startAudio = React.useCallback(async () => {\n    await roomEnsured.startAudio();\n  }, [roomEnsured]);\n\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured],\n  );\n  const { canPlayAudio } = useObservableState(observable, {\n    canPlayAudio: roomEnsured.canPlaybackAudio,\n  });\n\n  return { canPlayAudio, startAudio };\n}\n","/* eslint-disable no-return-assign */\n/* eslint-disable no-underscore-dangle */\nimport * as React from 'react';\nimport useLatest from '@react-hook/latest';\n\n/**\n * A React hook that fires a callback whenever ResizeObserver detects a change to its size\n * code extracted from https://github.com/jaredLunde/react-hook/blob/master/packages/resize-observer/src/index.tsx in order to not include the polyfill for resize-observer\n *\n * @internal\n */\nexport function useResizeObserver<T extends HTMLElement>(\n  target: React.RefObject<T>,\n  callback: UseResizeObserverCallback,\n) {\n  const resizeObserver = getResizeObserver();\n  const storedCallback = useLatest(callback);\n\n  React.useLayoutEffect(() => {\n    let didUnsubscribe = false;\n\n    const targetEl = target.current;\n    if (!targetEl) return;\n\n    function cb(entry: ResizeObserverEntry, observer: ResizeObserver) {\n      if (didUnsubscribe) return;\n      storedCallback.current(entry, observer);\n    }\n\n    resizeObserver?.subscribe(targetEl as HTMLElement, cb);\n\n    return () => {\n      didUnsubscribe = true;\n      resizeObserver?.unsubscribe(targetEl as HTMLElement, cb);\n    };\n  }, [target.current, resizeObserver, storedCallback]);\n\n  return resizeObserver?.observer;\n}\n\nfunction createResizeObserver() {\n  let ticking = false;\n  let allEntries: ResizeObserverEntry[] = [];\n\n  const callbacks: Map<unknown, Array<UseResizeObserverCallback>> = new Map();\n\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const observer = new ResizeObserver((entries: ResizeObserverEntry[], obs: ResizeObserver) => {\n    allEntries = allEntries.concat(entries);\n    if (!ticking) {\n      window.requestAnimationFrame(() => {\n        const triggered = new Set<Element>();\n        for (let i = 0; i < allEntries.length; i++) {\n          if (triggered.has(allEntries[i].target)) continue;\n          triggered.add(allEntries[i].target);\n          const cbs = callbacks.get(allEntries[i].target);\n          cbs?.forEach((cb) => cb(allEntries[i], obs));\n        }\n        allEntries = [];\n        ticking = false;\n      });\n    }\n    ticking = true;\n  });\n\n  return {\n    observer,\n    subscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\n      observer.observe(target);\n      const cbs = callbacks.get(target) ?? [];\n      cbs.push(callback);\n      callbacks.set(target, cbs);\n    },\n    unsubscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\n      const cbs = callbacks.get(target) ?? [];\n      if (cbs.length === 1) {\n        observer.unobserve(target);\n        callbacks.delete(target);\n        return;\n      }\n      const cbIndex = cbs.indexOf(callback);\n      if (cbIndex !== -1) cbs.splice(cbIndex, 1);\n      callbacks.set(target, cbs);\n    },\n  };\n}\n\nlet _resizeObserver: ReturnType<typeof createResizeObserver>;\n\nconst getResizeObserver = () =>\n  !_resizeObserver ? (_resizeObserver = createResizeObserver()) : _resizeObserver;\n\nexport type UseResizeObserverCallback = (\n  entry: ResizeObserverEntry,\n  observer: ResizeObserver,\n) => unknown;\n\nexport const useSize = (target: React.RefObject<HTMLDivElement>) => {\n  const [size, setSize] = React.useState({ width: 0, height: 0 });\n  React.useLayoutEffect(() => {\n    if (target.current) {\n      const { width, height } = target.current.getBoundingClientRect();\n      setSize({ width, height });\n    }\n  }, [target.current]);\n\n  const resizeCallback = React.useCallback(\n    (entry: ResizeObserverEntry) => setSize(entry.contentRect),\n    [],\n  );\n  // Where the magic happens\n  useResizeObserver(target, resizeCallback);\n  return size;\n};\n","import * as React from 'react';\nimport type { Observable } from 'rxjs';\n\n/**\n * @internal\n */\nexport function useObservableState<T>(observable: Observable<T> | undefined, startWith: T) {\n  const [state, setState] = React.useState<T>(startWith);\n  React.useEffect(() => {\n    // observable state doesn't run in SSR\n    if (typeof window === 'undefined' || !observable) return;\n    const subscription = observable.subscribe(setState);\n    return () => subscription.unsubscribe();\n  }, [observable]);\n  return state;\n}\n","import { PIN_DEFAULT_STATE, WIDGET_DEFAULT_STATE } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { PinContextType } from './pin-context';\nimport type { ChatContextType } from './chat-context';\nimport { chatReducer } from './chat-context';\nimport { pinReducer } from './pin-context';\n\n/** @public */\nexport type LayoutContextType = {\n  pin: PinContextType;\n  widget: ChatContextType;\n};\n\n/** @public */\nexport const LayoutContext = React.createContext<LayoutContextType | undefined>(undefined);\n\n/**\n * Ensures that a layout context is provided via context.\n * If no layout context is provided, an error is thrown.\n * @public\n */\nexport function useLayoutContext(): LayoutContextType {\n  const layoutContext = React.useContext(LayoutContext);\n  if (!layoutContext) {\n    throw Error('Tried to access LayoutContext context outside a LayoutContextProvider provider.');\n  }\n  return layoutContext;\n}\n\n/**\n * Ensures that a layout context is provided, either via context or explicitly as a parameter.\n * If not inside a `LayoutContext` and no layout context is provided, an error is thrown.\n * @public\n */\nexport function useEnsureLayoutContext(layoutContext?: LayoutContextType) {\n  const layout = useMaybeLayoutContext();\n  layoutContext ??= layout;\n  if (!layoutContext) {\n    throw Error('Tried to access LayoutContext context outside a LayoutContextProvider provider.');\n  }\n  return layoutContext;\n}\n\n/** @public */\nexport function useCreateLayoutContext(): LayoutContextType {\n  const [pinState, pinDispatch] = React.useReducer(pinReducer, PIN_DEFAULT_STATE);\n  const [widgetState, widgetDispatch] = React.useReducer(chatReducer, WIDGET_DEFAULT_STATE);\n  return {\n    pin: { dispatch: pinDispatch, state: pinState },\n    widget: { dispatch: widgetDispatch, state: widgetState },\n  };\n}\n\n/** @public */\nexport function useEnsureCreateLayoutContext(layoutContext?: LayoutContextType): LayoutContextType {\n  const [pinState, pinDispatch] = React.useReducer(pinReducer, PIN_DEFAULT_STATE);\n  const [widgetState, widgetDispatch] = React.useReducer(chatReducer, WIDGET_DEFAULT_STATE);\n  return (\n    layoutContext ?? {\n      pin: { dispatch: pinDispatch, state: pinState },\n      widget: { dispatch: widgetDispatch, state: widgetState },\n    }\n  );\n}\n\n/**\n * Returns a layout context from the `LayoutContext` if it exists, otherwise `undefined`.\n * @public\n */\nexport function useMaybeLayoutContext(): LayoutContextType | undefined {\n  return React.useContext(LayoutContext);\n}\n","import type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeTrackContext } from './track-context';\n\n/** @public */\nexport const ParticipantContext = React.createContext<Participant | undefined>(undefined);\n\n/**\n * Ensures that a participant is provided via context.\n * If not inside a `ParticipantContext`, an error is thrown.\n * @public\n */\nexport function useParticipantContext() {\n  const participant = React.useContext(ParticipantContext);\n  if (!participant) {\n    throw Error('tried to access participant context outside of participant context provider');\n  }\n  return participant;\n}\n\n/**\n * Returns a participant from the `ParticipantContext` if it exists, otherwise `undefined`.\n * @public\n */\nexport function useMaybeParticipantContext() {\n  return React.useContext(ParticipantContext);\n}\n\n/**\n * Ensures that a participant is provided, either via context or explicitly as a parameter.\n * If not inside a `ParticipantContext` and no participant is provided, an error is thrown.\n * @public\n */\nexport function useEnsureParticipant(participant?: Participant) {\n  const context = useMaybeParticipantContext();\n  const trackContext = useMaybeTrackContext();\n  const p = participant ?? context ?? trackContext?.participant;\n  if (!p) {\n    throw new Error(\n      'No participant provided, make sure you are inside a participant context or pass the participant explicitly',\n    );\n  }\n  return p;\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport const TrackContext = React.createContext<TrackReferenceOrPlaceholder | undefined>(undefined);\n\n/**\n * Ensures that a track reference is provided via context.\n * If not inside a `TrackContext`, an error is thrown.\n * @public\n */\nexport function useTrackContext() {\n  const trackReference = React.useContext(TrackContext);\n  if (!trackReference) {\n    throw Error('tried to access track context outside of track context provider');\n  }\n  return trackReference;\n}\n\n/**\n * Returns a track reference from the `TrackContext` if it exists, otherwise `undefined`.\n * @public\n */\nexport function useMaybeTrackContext() {\n  return React.useContext(TrackContext);\n}\n\n/**\n * Ensures that a track reference is provided, either via context or explicitly as a parameter.\n * If not inside a `TrackContext` and no track reference is provided, an error is thrown.\n * @public\n */\nexport function useEnsureTrackReference(track?: TrackReferenceOrPlaceholder) {\n  const context = useMaybeTrackContext();\n  const trackRef = track ?? context;\n  if (!trackRef) {\n    throw new Error(\n      'No TrackReference provided, make sure you are inside a track context or pass the track reference explicitly',\n    );\n  }\n  return trackRef;\n}\n","import type { Room } from 'livekit-client';\nimport * as React from 'react';\n\n/** @public */\nexport const RoomContext = React.createContext<Room | undefined>(undefined);\n\n/**\n * Ensures that a room is provided via context.\n * If no room is provided, an error is thrown.\n * @public\n */\nexport function useRoomContext() {\n  const ctx = React.useContext(RoomContext);\n  if (!ctx) {\n    throw Error('tried to access room context outside of livekit room component');\n  }\n  return ctx;\n}\n\n/**\n * Returns the room context if it exists, otherwise undefined.\n * @public\n */\nexport function useMaybeRoomContext() {\n  return React.useContext(RoomContext);\n}\n\n/**\n * Ensures that a room is provided, either via context or explicitly as a parameter.\n * If no room is provided, an error is thrown.\n * @public\n */\nexport function useEnsureRoom(room?: Room) {\n  const context = useMaybeRoomContext();\n  const r = room ?? context;\n  if (!r) {\n    throw new Error(\n      'No room provided, make sure you are inside a Room context or pass the room explicitly',\n    );\n  }\n  return r;\n}\n","import { setupClearPinButton } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport type { ClearPinButtonProps } from '../components';\n\n/** @public */\nexport function useClearPinButton(props: ClearPinButtonProps) {\n  const { state, dispatch } = useLayoutContext().pin;\n\n  const buttonProps = React.useMemo(() => {\n    const { className } = setupClearPinButton();\n    const mergedProps = mergeProps(props, {\n      className,\n      disabled: !state?.length,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'clear_pin' });\n      },\n    });\n    return mergedProps;\n  }, [props, dispatch, state]);\n\n  return { buttonProps };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport clsx from 'clsx';\n\n/**\n * Calls all functions in the order they were chained with the same arguments.\n * @internal\n */\nexport function chain(...callbacks: any[]): (...args: any[]) => void {\n  return (...args: any[]) => {\n    for (const callback of callbacks) {\n      if (typeof callback === 'function') {\n        callback(...args);\n      }\n    }\n  };\n}\n\ninterface Props {\n  [key: string]: any;\n}\n\n// taken from: https://stackoverflow.com/questions/51603250/typescript-3-parameter-list-intersection-type/51604379#51604379\ntype TupleTypes<T> = { [P in keyof T]: T[P] } extends { [key: number]: infer V } ? V : never;\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\n  ? I\n  : never;\n\n/**\n * Merges multiple props objects together. Event handlers are chained,\n * classNames are combined, and ids are deduplicated - different ids\n * will trigger a side-effect and re-render components hooked up with `useId`.\n * For all other props, the last prop object overrides all previous ones.\n * @param args - Multiple sets of props to merge together.\n * @internal\n */\nexport function mergeProps<T extends Props[]>(...args: T): UnionToIntersection<TupleTypes<T>> {\n  // Start with a base clone of the first argument. This is a lot faster than starting\n  // with an empty object and adding properties as we go.\n  const result: Props = { ...args[0] };\n  for (let i = 1; i < args.length; i++) {\n    const props = args[i];\n    for (const key in props) {\n      const a = result[key];\n      const b = props[key];\n\n      // Chain events\n      if (\n        typeof a === 'function' &&\n        typeof b === 'function' &&\n        // This is a lot faster than a regex.\n        key[0] === 'o' &&\n        key[1] === 'n' &&\n        key.charCodeAt(2) >= /* 'A' */ 65 &&\n        key.charCodeAt(2) <= /* 'Z' */ 90\n      ) {\n        result[key] = chain(a, b);\n\n        // Merge classnames, sometimes classNames are empty string which eval to false, so we just need to do a type check\n      } else if (\n        (key === 'className' || key === 'UNSAFE_className') &&\n        typeof a === 'string' &&\n        typeof b === 'string'\n      ) {\n        result[key] = clsx(a, b);\n      } else {\n        result[key] = b !== undefined ? b : a;\n      }\n    }\n  }\n\n  return result as UnionToIntersection<TupleTypes<T>>;\n}\n","import { setupConnectionQualityIndicator } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport { ConnectionQuality } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface ConnectionQualityIndicatorOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useConnectionQualityIndicator(options: ConnectionQualityIndicatorOptions = {}) {\n  const p = useEnsureParticipant(options.participant);\n\n  const { className, connectionQualityObserver } = React.useMemo(\n    () => setupConnectionQualityIndicator(p),\n    [p],\n  );\n\n  const quality = useObservableState(connectionQualityObserver, ConnectionQuality.Unknown);\n\n  return { className, quality };\n}\n","import { connectionStateObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useConnectionState` hook allows you to simply implement your own `ConnectionState` component.\n *\n * @example\n * ```tsx\n * const connectionState = useConnectionState(room);\n * ```\n * @public\n */\nexport function useConnectionState(room?: Room) {\n  // passed room takes precedence, if not supplied get current room context\n  const r = useEnsureRoom(room);\n  const observable = React.useMemo(() => connectionStateObserver(r), [r]);\n  const connectionState = useObservableState(observable, r.state);\n  return connectionState;\n}\n","import type { DataSendOptions, ReceivedDataMessage } from '@livekit/components-core';\nimport { setupDataMessageHandler } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\ntype UseDataChannelReturnType<T extends string | undefined = undefined> = {\n  isSending: boolean;\n  send: (payload: Uint8Array, options: DataSendOptions) => void;\n  message: ReceivedDataMessage<T> | undefined;\n};\n\n/**\n * @public\n */\nexport function useDataChannel<T extends string>(\n  topic: T,\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\n): UseDataChannelReturnType<T>;\n/**\n * @public\n */\nexport function useDataChannel(\n  onMessage?: (msg: ReceivedDataMessage) => void,\n): UseDataChannelReturnType;\n/**\n * @internal\n */\nexport function useDataChannel<T extends string>(\n  topicOrCallback?: T | ((msg: ReceivedDataMessage) => void),\n  callback?: (msg: ReceivedDataMessage<T>) => void,\n) {\n  const onMessage = typeof topicOrCallback === 'function' ? topicOrCallback : callback;\n\n  const topic = typeof topicOrCallback === 'string' ? topicOrCallback : undefined;\n  const room = useRoomContext();\n  const { send, messageObservable, isSendingObservable } = React.useMemo(\n    () => setupDataMessageHandler(room, topic, onMessage),\n    [room, topic, onMessage],\n  );\n\n  const message = useObservableState(messageObservable, undefined);\n  const isSending = useObservableState(isSendingObservable, false);\n\n  return {\n    message,\n    send,\n    isSending,\n  };\n}\n","import { setupDisconnectButton } from '@livekit/components-core';\nimport { ConnectionState } from 'livekit-client';\nimport * as React from 'react';\nimport type { DisconnectButtonProps } from '../components';\nimport { useRoomContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useConnectionState } from './useConnectionStatus';\n\n/** @public */\nexport function useDisconnectButton(props: DisconnectButtonProps) {\n  const room = useRoomContext();\n  const connectionState = useConnectionState(room);\n\n  const buttonProps = React.useMemo(() => {\n    const { className, disconnect } = setupDisconnectButton(room);\n    const mergedProps = mergeProps(props, {\n      className,\n      onClick: () => disconnect(props.stopTracks ?? true),\n      disabled: connectionState === ConnectionState.Disconnected,\n    });\n    return mergedProps;\n  }, [room, props, connectionState]);\n\n  return { buttonProps };\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { LocalTrackPublication, facingModeFromLocalTrack } from 'livekit-client';\n\n/**\n * Try to determine the `facingMode` of a local participant video track.\n * @remarks\n * Works only on local video tracks.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @alpha\n */\nexport function useFacingMode(\n  trackReference: TrackReferenceOrPlaceholder,\n): 'user' | 'environment' | 'left' | 'right' | 'undefined' {\n  if (trackReference.publication instanceof LocalTrackPublication) {\n    const localTrack = trackReference.publication.track;\n    if (localTrack) {\n      const { facingMode } = facingModeFromLocalTrack(localTrack);\n      return facingMode;\n    }\n  }\n  return 'undefined';\n}\n","import { setupFocusToggle, isTrackReferencePinned } from '@livekit/components-core';\nimport type { Track, Participant } from 'livekit-client';\nimport { useEnsureParticipant, useMaybeLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseFocusToggleProps {\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n  trackSource: Track.Source;\n  participant?: Participant;\n}\n\n/** @public */\nexport function useFocusToggle({ trackSource, participant, props }: UseFocusToggleProps) {\n  const p = useEnsureParticipant(participant);\n  const layoutContext = useMaybeLayoutContext();\n  const { className } = React.useMemo(() => setupFocusToggle(), []);\n\n  const inFocus: boolean = React.useMemo(() => {\n    const track = p.getTrack(trackSource);\n    if (layoutContext?.pin.state && track) {\n      return isTrackReferencePinned(\n        { participant: p, source: trackSource, publication: track },\n        layoutContext.pin.state,\n      );\n    } else {\n      return false;\n    }\n  }, [p, trackSource, layoutContext]);\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n          // Call user defined on click callbacks.\n          props.onClick?.(event);\n\n          // Set or clear focus based on current focus state.\n          const track = p.getTrack(trackSource);\n          if (layoutContext?.pin.dispatch && track) {\n            if (inFocus) {\n              layoutContext.pin.dispatch({\n                msg: 'clear_pin',\n              });\n            } else {\n              layoutContext.pin.dispatch({\n                msg: 'set_pin',\n                trackReference: {\n                  participant: p,\n                  publication: track,\n                  source: track.source,\n                },\n              });\n            }\n          }\n        },\n      }),\n    [props, className, p, trackSource, inFocus, layoutContext],\n  );\n\n  return { mergedProps, inFocus };\n}\n","import { GRID_LAYOUTS, selectGridLayout } from '@livekit/components-core';\nimport type { GridLayoutDefinition } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useSize } from './internal';\n\n/**\n * The useGridLayout hook tries to select the best layout to fit all tiles.\n * If the available screen space is not enough, it will reduce the number of maximum visible\n * tiles and select a layout that still works visually within the given limitations.\n * As the order of tiles changes over time, the hook tries to keep visual updates to a minimum\n * while trying to display important tiles such as speaking participants or screen shares.\n * @public\n */\nexport function useGridLayout(\n  /** HTML element that contains the grid. */\n  gridElement: React.RefObject<HTMLDivElement>,\n  /** Count of tracks that should get layed out */\n  trackCount: number,\n): { layout: GridLayoutDefinition } {\n  const { width, height } = useSize(gridElement);\n\n  const layout =\n    width > 0 && height > 0\n      ? selectGridLayout(GRID_LAYOUTS, trackCount, width, height)\n      : GRID_LAYOUTS[0];\n\n  React.useEffect(() => {\n    if (gridElement.current && layout) {\n      gridElement.current.style.setProperty('--lk-col-count', layout?.columns.toString());\n      gridElement.current.style.setProperty('--lk-row-count', layout?.rows.toString());\n    }\n  }, [gridElement, layout]);\n\n  return {\n    layout,\n  };\n}\n","import { mutedObserver } from '@livekit/components-core';\nimport type { Participant, Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\n\n/** @public */\nexport interface UseIsMutedOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useIsMuted(source: Track.Source, options: UseIsMutedOptions = {}) {\n  const p = useEnsureParticipant(options.participant);\n  const [isMuted, setIsMuted] = React.useState(!!p.getTrack(source)?.isMuted);\n\n  React.useEffect(() => {\n    const listener = mutedObserver(p, source).subscribe(setIsMuted);\n    return () => listener.unsubscribe();\n  }, [p, source]);\n\n  return isMuted;\n}\n","import { createIsSpeakingObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport function useIsSpeaking(participant?: Participant) {\n  const p = useEnsureParticipant(participant);\n  const observable = React.useMemo(() => createIsSpeakingObserver(p), [p]);\n  const isSpeaking = useObservableState(observable, p.isSpeaking);\n\n  return isSpeaking;\n}\n","import { log, setupLiveKitRoom } from '@livekit/components-core';\nimport { Room, MediaDeviceFailure, RoomEvent, ConnectionState } from 'livekit-client';\nimport * as React from 'react';\nimport type { HTMLAttributes } from 'react';\n\nimport type { LiveKitRoomProps } from '../components';\nimport { mergeProps } from '../mergeProps';\n\nconst defaultRoomProps: Partial<LiveKitRoomProps> = {\n  connect: true,\n  audio: false,\n  video: false,\n};\n\n/** @public */\nexport function useLiveKitRoom<T extends HTMLElement>(\n  props: LiveKitRoomProps,\n): {\n  room: Room | undefined;\n  htmlProps: HTMLAttributes<T>;\n} {\n  const {\n    token,\n    serverUrl,\n    options,\n    room: passedRoom,\n    connectOptions,\n    connect,\n    audio,\n    video,\n    screen,\n    onConnected,\n    onDisconnected,\n    onError,\n    onMediaDeviceFailure,\n    simulateParticipants,\n    ...rest\n  } = { ...defaultRoomProps, ...props };\n  if (options && passedRoom) {\n    log.warn(\n      'when using a manually created room, the options object will be ignored. set the desired options directly when creating the room instead.',\n    );\n  }\n\n  const [room, setRoom] = React.useState<Room | undefined>();\n\n  React.useEffect(() => {\n    setRoom(passedRoom ?? new Room(options));\n  }, [JSON.stringify(options), passedRoom]);\n\n  const htmlProps = React.useMemo(() => {\n    const { className } = setupLiveKitRoom();\n    return mergeProps(rest, { className }) as HTMLAttributes<T>;\n  }, [rest]);\n\n  React.useEffect(() => {\n    if (!room) return;\n    const onSignalConnected = () => {\n      const localP = room.localParticipant;\n\n      log.debug('trying to publish local tracks');\n      Promise.all([\n        localP.setMicrophoneEnabled(!!audio, typeof audio !== 'boolean' ? audio : undefined),\n        localP.setCameraEnabled(!!video, typeof video !== 'boolean' ? video : undefined),\n        localP.setScreenShareEnabled(!!screen, typeof screen !== 'boolean' ? screen : undefined),\n      ]).catch((e) => {\n        log.warn(e);\n        onError?.(e as Error);\n      });\n    };\n\n    const onMediaDeviceError = (e: Error) => {\n      const mediaDeviceFailure = MediaDeviceFailure.getFailure(e);\n      onMediaDeviceFailure?.(mediaDeviceFailure);\n    };\n    room.on(RoomEvent.SignalConnected, onSignalConnected);\n    room.on(RoomEvent.MediaDevicesError, onMediaDeviceError);\n\n    return () => {\n      room.off(RoomEvent.SignalConnected, onSignalConnected);\n      room.off(RoomEvent.MediaDevicesError, onMediaDeviceError);\n    };\n  }, [room, audio, video, screen, onError]);\n\n  React.useEffect(() => {\n    if (!room) return;\n\n    if (simulateParticipants) {\n      room.simulateParticipants({\n        participants: {\n          count: simulateParticipants,\n        },\n        publish: {\n          audio: true,\n          useRealTracks: true,\n        },\n      });\n      return;\n    }\n    if (!token) {\n      log.debug('no token yet');\n      return;\n    }\n    if (!serverUrl) {\n      log.warn('no livekit url provided');\n      onError?.(Error('no livekit url provided'));\n      return;\n    }\n    if (connect) {\n      log.debug('connecting');\n      room.connect(serverUrl, token, connectOptions).catch((e) => {\n        log.warn(e);\n        onError?.(e as Error);\n      });\n    } else {\n      log.debug('disconnecting because connect is false');\n      room.disconnect();\n    }\n  }, [\n    connect,\n    token,\n    JSON.stringify(connectOptions),\n    room,\n    onError,\n    serverUrl,\n    simulateParticipants,\n  ]);\n\n  React.useEffect(() => {\n    if (!room) return;\n    const connectionStateChangeListener = (state: ConnectionState) => {\n      switch (state) {\n        case ConnectionState.Disconnected:\n          if (onDisconnected) onDisconnected();\n          break;\n        case ConnectionState.Connected:\n          if (onConnected) onConnected();\n          break;\n\n        default:\n          break;\n      }\n    };\n    room.on(RoomEvent.ConnectionStateChanged, connectionStateChangeListener);\n    return () => {\n      room.off(RoomEvent.ConnectionStateChanged, connectionStateChangeListener);\n    };\n  }, [token, onConnected, onDisconnected, room]);\n\n  React.useEffect(() => {\n    if (!room) return;\n    return () => {\n      log.info('disconnecting on onmount');\n      room.disconnect();\n    };\n  }, [room]);\n\n  return { room, htmlProps };\n}\n","import type { ParticipantMedia } from '@livekit/components-core';\nimport { observeParticipantMedia } from '@livekit/components-core';\nimport type { TrackPublication, LocalParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseLocalParticipantOptions {\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The useLocalParticipant hook the state of the local participant.\n * @public\n */\nexport function useLocalParticipant(options: UseLocalParticipantOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [localParticipant, setLocalParticipant] = React.useState(room.localParticipant);\n  const [isMicrophoneEnabled, setIsMicrophoneEnabled] = React.useState(\n    localParticipant.isMicrophoneEnabled,\n  );\n  const [isCameraEnabled, setIsCameraEnabled] = React.useState(\n    localParticipant.isMicrophoneEnabled,\n  );\n  const [lastMicrophoneError, setLastMicrophoneError] = React.useState(\n    localParticipant.lastMicrophoneError,\n  );\n  const [lastCameraError, setLastCameraError] = React.useState(localParticipant.lastCameraError);\n  const [isScreenShareEnabled, setIsScreenShareEnabled] = React.useState(\n    localParticipant.isMicrophoneEnabled,\n  );\n  const [microphoneTrack, setMicrophoneTrack] = React.useState<TrackPublication | undefined>(\n    undefined,\n  );\n  const [cameraTrack, setCameraTrack] = React.useState<TrackPublication | undefined>(undefined);\n\n  const handleUpdate = (media: ParticipantMedia<LocalParticipant>) => {\n    setIsCameraEnabled(media.isCameraEnabled);\n    setIsMicrophoneEnabled(media.isMicrophoneEnabled);\n    setIsScreenShareEnabled(media.isScreenShareEnabled);\n    setCameraTrack(media.cameraTrack);\n    setMicrophoneTrack(media.microphoneTrack);\n    setLastMicrophoneError(media.participant.lastMicrophoneError);\n    setLastCameraError(media.participant.lastCameraError);\n    setLocalParticipant(media.participant);\n  };\n  React.useEffect(() => {\n    const listener = observeParticipantMedia(localParticipant).subscribe(handleUpdate);\n    // TODO also listen to permission and metadata etc. events\n    return () => listener.unsubscribe();\n  }, [localParticipant]);\n\n  return {\n    isMicrophoneEnabled,\n    isScreenShareEnabled,\n    isCameraEnabled,\n    microphoneTrack,\n    cameraTrack,\n    lastMicrophoneError,\n    lastCameraError,\n    localParticipant,\n  };\n}\n","import { participantPermissionObserver } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport function useLocalParticipantPermissions() {\n  const room = useRoomContext();\n  const permissionObserver = React.useMemo(\n    () => participantPermissionObserver(room.localParticipant),\n    [room],\n  );\n  const permissions = useObservableState(permissionObserver, room.localParticipant.permissions);\n  return permissions;\n}\n","import { createMediaDeviceObserver, setupDeviceSelector, log } from '@livekit/components-core';\nimport type { LocalAudioTrack, LocalVideoTrack, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseMediaDeviceSelectProps {\n  kind: MediaDeviceKind;\n  room?: Room;\n  track?: LocalAudioTrack | LocalVideoTrack;\n  /**\n   * this will call getUserMedia if the permissions are not yet given to enumerate the devices with device labels.\n   * in some browsers multiple calls to getUserMedia result in multiple permission prompts.\n   * It's generally advised only flip this to true, once a (preview) track has been acquired successfully with the\n   * appropriate permissions.\n   *\n   * @see {@link MediaDeviceMenu}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices | MDN enumerateDevices}\n   */\n  requestPermissions?: boolean;\n}\n\n/** @public */\nexport function useMediaDeviceSelect({\n  kind,\n  room,\n  track,\n  requestPermissions,\n}: UseMediaDeviceSelectProps) {\n  const roomContext = useMaybeRoomContext();\n  // List of all devices.\n  const deviceObserver = React.useMemo(\n    () => createMediaDeviceObserver(kind, requestPermissions),\n    [kind, requestPermissions],\n  );\n  const devices = useObservableState(deviceObserver, []);\n  // Active device management.\n  const [currentDeviceId, setCurrentDeviceId] = React.useState<string>('');\n  const { className, activeDeviceObservable, setActiveMediaDevice } = React.useMemo(\n    () => setupDeviceSelector(kind, room ?? roomContext, track),\n    [kind, room, roomContext, track],\n  );\n\n  React.useEffect(() => {\n    const listener = activeDeviceObservable.subscribe((deviceId) => {\n      log.info('setCurrentDeviceId', deviceId);\n      if (deviceId) setCurrentDeviceId(deviceId);\n    });\n    return () => {\n      listener?.unsubscribe();\n    };\n  }, [activeDeviceObservable]);\n\n  return { devices, className, activeDeviceId: currentDeviceId, setActiveMediaDevice };\n}\n","import * as React from 'react';\nimport { useObservableState } from './internal';\nimport { createMediaDeviceObserver } from '@livekit/components-core';\n\n/** @public */\nexport function useMediaDevices({ kind }: { kind: MediaDeviceKind }) {\n  const deviceObserver = React.useMemo(() => createMediaDeviceObserver(kind), [kind]);\n  const devices = useObservableState(deviceObserver, []);\n  return devices;\n}\n","import type { TrackIdentifier } from '@livekit/components-core';\nimport { isTrackReference } from '@livekit/components-core';\nimport { setupMediaTrack, log, isLocal, getTrackByIdentifier } from '@livekit/components-core';\nimport * as React from 'react';\nimport { mergeProps } from '../utils';\nimport type { UseMediaTrackOptions } from './useMediaTrack';\n\n/**\n * @internal\n */\nexport function useMediaTrackBySourceOrName(\n  observerOptions: TrackIdentifier,\n  options: UseMediaTrackOptions = {},\n) {\n  const [publication, setPublication] = React.useState(getTrackByIdentifier(observerOptions));\n\n  const [isMuted, setMuted] = React.useState(publication?.isMuted);\n  const [isSubscribed, setSubscribed] = React.useState(publication?.isSubscribed);\n  const [track, setTrack] = React.useState(publication?.track);\n  const [orientation, setOrientation] = React.useState<'landscape' | 'portrait'>('landscape');\n  const previousElement = React.useRef<HTMLMediaElement | undefined | null>();\n\n  const { className, trackObserver } = React.useMemo(() => {\n    return setupMediaTrack(observerOptions);\n  }, [\n    observerOptions.participant.identity,\n    observerOptions.source,\n    isTrackReference(observerOptions) && observerOptions.publication.trackSid,\n  ]);\n\n  React.useEffect(() => {\n    const subscription = trackObserver.subscribe((publication) => {\n      log.debug('update track', publication);\n      setPublication(publication);\n      setMuted(publication?.isMuted);\n      setSubscribed(publication?.isSubscribed);\n      setTrack(publication?.track);\n    });\n    return () => subscription?.unsubscribe();\n  }, [trackObserver]);\n\n  React.useEffect(() => {\n    if (track) {\n      if (previousElement.current) {\n        track.detach(previousElement.current);\n      }\n      if (\n        options.element?.current &&\n        !(isLocal(observerOptions.participant) && track?.kind === 'audio')\n      ) {\n        track.attach(options.element.current);\n      }\n    }\n    previousElement.current = options.element?.current;\n    return () => {\n      if (previousElement.current) {\n        track?.detach(previousElement.current);\n      }\n    };\n  }, [track, options.element]);\n\n  React.useEffect(() => {\n    // Set the orientation of the video track.\n    // TODO: This does not handle changes in orientation after a track got published (e.g when rotating a phone camera from portrait to landscape).\n    if (\n      typeof publication?.dimensions?.width === 'number' &&\n      typeof publication?.dimensions?.height === 'number'\n    ) {\n      const orientation_ =\n        publication.dimensions.width > publication.dimensions.height ? 'landscape' : 'portrait';\n      setOrientation(orientation_);\n    }\n  }, [publication]);\n\n  return {\n    publication,\n    isMuted,\n    isSubscribed,\n    track,\n    elementProps: mergeProps(options.props, {\n      className,\n      'data-lk-local-participant': observerOptions.participant.isLocal,\n      'data-lk-source': publication?.source,\n      ...(publication?.kind === 'video' && { 'data-lk-orientation': orientation }),\n    }),\n  };\n}\n","import * as React from 'react';\nimport { mergeProps as mergePropsReactAria } from './mergeProps';\n\n/** @internal */\nexport function isProp<U extends HTMLElement, T extends React.HTMLAttributes<U>>(\n  prop: T | undefined,\n): prop is T {\n  return prop !== undefined;\n}\n\n/** @internal */\nexport function mergeProps<\n  U extends HTMLElement,\n  T extends Array<React.HTMLAttributes<U> | undefined>,\n>(...props: T) {\n  return mergePropsReactAria(...props.filter(isProp));\n}\n\n/** @internal */\nexport function cloneSingleChild(\n  children: React.ReactNode | React.ReactNode[],\n  props?: Record<string, any>,\n  key?: any,\n) {\n  return React.Children.map(children, (child) => {\n    // Checking isValidElement is the safe way and avoids a typescript\n    // error too.\n    if (React.isValidElement(child) && React.Children.only(children)) {\n      return React.cloneElement(child, { ...props, key });\n    }\n    return child;\n  });\n}\n","import type { VideoSource, AudioSource } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport { useEnsureParticipant } from '../context/participant-context';\nimport type * as React from 'react';\nimport { useMediaTrackBySourceOrName } from './useMediaTrackBySourceOrName';\n\n/** @public */\nexport interface UseMediaTrackOptions {\n  element?: React.RefObject<HTMLMediaElement>;\n  props?: React.HTMLAttributes<HTMLVideoElement | HTMLAudioElement>;\n}\n\n/** @public */\nexport function useMediaTrack(\n  source: VideoSource | AudioSource,\n  participant?: Participant,\n  options: UseMediaTrackOptions = {},\n) {\n  const p = useEnsureParticipant(participant);\n  return useMediaTrackBySourceOrName({ source, participant: p }, options);\n}\n","import type { Participant } from 'livekit-client';\nimport { useEnsureParticipant } from '../context';\nimport type { UseMediaTrackOptions } from './useMediaTrack';\nimport { useMediaTrackBySourceOrName } from './useMediaTrackBySourceOrName';\n\n/** @public */\nexport function useMediaTrackByName(\n  name: string,\n  participant?: Participant,\n  options: UseMediaTrackOptions = {},\n) {\n  const p = useEnsureParticipant(participant);\n  return useMediaTrackBySourceOrName({ name, participant: p }, options);\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useVisualStableUpdate } from './useVisualStableUpdate';\n\n/**\n * The `usePagination` hook implements simple pagination logic for use with arrays.\n * @example\n * ```tsx\n * const tracks = useTracks();\n * const pagination = usePagination(4, tracks);\n *\n * <TrackLoop tracks={pagination.tracks} />\n * ```\n * @alpha\n */\nexport function usePagination(itemPerPage: number, trackReferences: TrackReferenceOrPlaceholder[]) {\n  const [currentPage, setCurrentPage] = React.useState(1);\n  const totalPageCount = Math.max(Math.ceil(trackReferences.length / itemPerPage), 1);\n  if (currentPage > totalPageCount) {\n    setCurrentPage(totalPageCount);\n  }\n  const lastItemIndex = currentPage * itemPerPage;\n  const firstItemIndex = lastItemIndex - itemPerPage;\n\n  const changePage = (direction: 'next' | 'previous') => {\n    setCurrentPage((state) => {\n      if (direction === 'next') {\n        if (state === totalPageCount) {\n          return state;\n        }\n        return state + 1;\n      } else {\n        if (state === 1) {\n          return state;\n        }\n        return state - 1;\n      }\n    });\n  };\n\n  const goToPage = (num: number) => {\n    if (num > totalPageCount) {\n      setCurrentPage(totalPageCount);\n    } else if (num < 1) {\n      setCurrentPage(1);\n    } else {\n      setCurrentPage(num);\n    }\n  };\n\n  const updatedTrackReferences = useVisualStableUpdate(trackReferences, itemPerPage);\n\n  const tracksOnPage = updatedTrackReferences.slice(firstItemIndex, lastItemIndex);\n\n  return {\n    totalPageCount,\n    nextPage: () => changePage('next'),\n    prevPage: () => changePage('previous'),\n    setPage: goToPage,\n    firstItemIndex,\n    lastItemIndex,\n    tracks: tracksOnPage,\n    currentPage,\n  };\n}\n\nexport default usePagination;\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { log, sortTrackReferences, updatePages } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseVisualStableUpdateOptions {\n  /** Overwrites the default sort function. */\n  customSortFunction?: (\n    trackReferences: TrackReferenceOrPlaceholder[],\n  ) => TrackReferenceOrPlaceholder[];\n}\n\n/**\n * The useVisualStableUpdate hook tries to keep visual updates of the TackBundles array to a minimum,\n * while still trying to display important tiles such as speaking participants or screen shares.\n *\n * Updating works with pagination. For example, if a participant starts speaking on the second page,\n * they will be moved to the first page by replacing the least active/interesting participant on the first page.\n *\n * @beta\n */\nexport function useVisualStableUpdate(\n  /** `TrackReference`s to display in the grid.  */\n  trackReferences: TrackReferenceOrPlaceholder[],\n  maxItemsOnPage: number,\n  options: UseVisualStableUpdateOptions = {},\n): TrackReferenceOrPlaceholder[] {\n  const lastTrackRefs = React.useRef<TrackReferenceOrPlaceholder[]>([]);\n  const lastMaxItemsOnPage = React.useRef<number>(-1);\n  const layoutChanged = maxItemsOnPage !== lastMaxItemsOnPage.current;\n\n  const sortedTrackRefs =\n    typeof options.customSortFunction === 'function'\n      ? options.customSortFunction(trackReferences)\n      : sortTrackReferences(trackReferences);\n\n  let updatedTrackRefs: TrackReferenceOrPlaceholder[] = [...sortedTrackRefs];\n  if (layoutChanged === false) {\n    try {\n      updatedTrackRefs = updatePages(lastTrackRefs.current, sortedTrackRefs, maxItemsOnPage);\n    } catch (error) {\n      log.error('Error while running updatePages(): ', error);\n    }\n  }\n\n  // Save info for to compare against in the next update cycle.\n  if (layoutChanged) {\n    lastTrackRefs.current = sortedTrackRefs;\n  } else {\n    lastTrackRefs.current = updatedTrackRefs;\n  }\n  lastMaxItemsOnPage.current = maxItemsOnPage;\n\n  return updatedTrackRefs;\n}\n","import { participantInfoObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseParticipantInfoOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantInfo(props: UseParticipantInfoOptions = {}) {\n  const p = useEnsureParticipant(props.participant);\n  const infoObserver = React.useMemo(() => participantInfoObserver(p), [p]);\n  const { identity, name, metadata } = useObservableState(infoObserver, {\n    name: p.name,\n    identity: p.identity,\n    metadata: p.metadata,\n  });\n\n  return { identity, name, metadata };\n}\n","import * as React from 'react';\nimport type { Participant } from 'livekit-client';\nimport { participantPermissionObserver } from '@livekit/components-core';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal/useObservableState';\n\n/** @public */\nexport interface UseParticipantPermissionsOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantPermissions(options: UseParticipantPermissionsOptions = {}) {\n  const p = useEnsureParticipant(options.participant);\n  const permissionObserver = React.useMemo(() => participantPermissionObserver(p), [p]);\n  const permissions = useObservableState(permissionObserver, p.permissions);\n  return permissions;\n}\n","import type { ParticipantClickEvent } from '@livekit/components-core';\nimport { setupParticipantTile } from '@livekit/components-core';\nimport type { TrackPublication, Participant } from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useFacingMode } from './useFacingMode';\nimport { useIsMuted } from './useIsMuted';\nimport { useIsSpeaking } from './useIsSpeaking';\n\n/** @public */\nexport interface UseParticipantTileProps<T extends HTMLElement> extends React.HTMLAttributes<T> {\n  disableSpeakingIndicator?: boolean;\n  publication?: TrackPublication;\n  onParticipantClick?: (event: ParticipantClickEvent) => void;\n  htmlProps: React.HTMLAttributes<T>;\n  source: Track.Source;\n  participant: Participant;\n}\n\n/** @public */\nexport function useParticipantTile<T extends HTMLElement>({\n  participant,\n  source,\n  publication,\n  onParticipantClick,\n  disableSpeakingIndicator,\n  htmlProps,\n}: UseParticipantTileProps<T>) {\n  const p = useEnsureParticipant(participant);\n  const mergedProps = React.useMemo(() => {\n    const { className } = setupParticipantTile();\n    return mergeProps(htmlProps, {\n      className,\n      onClick: (event: React.MouseEvent<T, MouseEvent>) => {\n        htmlProps.onClick?.(event);\n        if (typeof onParticipantClick === 'function') {\n          const track = publication ?? p.getTrack(source);\n          onParticipantClick({ participant: p, track });\n        }\n      },\n    });\n  }, [htmlProps, source, onParticipantClick, p, publication]);\n  const isVideoMuted = useIsMuted(Track.Source.Camera, { participant });\n  const isAudioMuted = useIsMuted(Track.Source.Microphone, { participant });\n  const isSpeaking = useIsSpeaking(participant);\n  const facingMode = useFacingMode({ participant, publication, source });\n  return {\n    elementProps: {\n      'data-lk-audio-muted': isAudioMuted,\n      'data-lk-video-muted': isVideoMuted,\n      'data-lk-speaking': disableSpeakingIndicator === true ? false : isSpeaking,\n      'data-lk-local-participant': participant.isLocal,\n      'data-lk-source': source,\n      'data-lk-facing-mode': facingMode,\n      ...mergedProps,\n    } as React.HTMLAttributes<T>,\n  };\n}\n","import { connectedParticipantsObserver } from '@livekit/components-core';\nimport type { RoomEvent, RemoteParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The useRemoteParticipants\n *\n * @public\n */\nexport function useRemoteParticipants(options: UseRemoteParticipantsOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [participants, setParticipants] = React.useState<RemoteParticipant[]>([]);\n\n  React.useEffect(() => {\n    const listener = connectedParticipantsObserver(room, {\n      additionalRoomEvents: options.updateOnlyOn,\n    }).subscribe(setParticipants);\n    return () => listener.unsubscribe();\n  }, [room, JSON.stringify(options.updateOnlyOn)]);\n  return participants;\n}\n","import type { Room, RoomEvent } from 'livekit-client';\nimport { useLocalParticipant } from './useLocalParticipant';\nimport { useRemoteParticipants } from './useRemoteParticipants';\n\n/** @public */\nexport interface UseParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The useParticipants hook returns all participants (local and remote) of the current room.\n * @public\n */\nexport function useParticipants(options: UseParticipantsOptions = {}) {\n  const remoteParticipants = useRemoteParticipants(options);\n  const { localParticipant } = useLocalParticipant(options);\n\n  return [localParticipant, ...remoteParticipants];\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { LayoutContextType } from '../context';\nimport { useEnsureLayoutContext } from '../context';\n\n/** @public */\nexport function usePinnedTracks(layoutContext?: LayoutContextType): TrackReferenceOrPlaceholder[] {\n  layoutContext = useEnsureLayoutContext(layoutContext);\n  return React.useMemo(() => {\n    if (layoutContext?.pin.state !== undefined && layoutContext.pin.state.length >= 1) {\n      return layoutContext.pin.state;\n    }\n    return [];\n  }, [layoutContext.pin.state]);\n}\n","import { connectedParticipantObserver } from '@livekit/components-core';\nimport type { ParticipantEvent, RemoteParticipant } from 'livekit-client';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseRemoteParticipantOptions {\n  updateOnlyOn?: ParticipantEvent[];\n}\n\n/** @public */\nexport function useRemoteParticipant(\n  identity: string,\n  options: UseRemoteParticipantOptions = {},\n): RemoteParticipant | undefined {\n  const room = useRoomContext();\n  const [updateOnlyOn] = React.useState(options.updateOnlyOn);\n\n  const observable = React.useMemo(\n    () => connectedParticipantObserver(room, identity, { additionalEvents: updateOnlyOn }),\n    [room, identity, updateOnlyOn],\n  );\n  const participant = useObservableState(\n    observable,\n    room.getParticipantByIdentity(identity) as RemoteParticipant | undefined,\n  );\n  return participant;\n}\n","import { roomInfoObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseRoomInfoOptions {\n  room?: Room;\n}\n\n/** @public */\nexport function useRoomInfo(options: UseRoomInfoOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const infoObserver = React.useMemo(() => roomInfoObserver(room), [room]);\n  const { name, metadata } = useObservableState(infoObserver, {\n    name: room.name,\n    metadata: room.metadata,\n  });\n\n  return { name, metadata };\n}\n","import { sortParticipants } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useSpeakingParticipants } from './useSpeakingParticipants';\n\n/**\n * The useSortedParticipants hook returns the only the active speakers of all participants.\n *\n * @public\n */\nexport function useSortedParticipants(participants: Array<Participant>) {\n  const [sortedParticipants, setSortedParticipants] = React.useState(\n    sortParticipants(participants),\n  );\n  const activeSpeakers = useSpeakingParticipants();\n\n  React.useEffect(() => {\n    setSortedParticipants(sortParticipants(participants));\n  }, [activeSpeakers, participants]);\n  return sortedParticipants;\n}\n","import { activeSpeakerObserver } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The useSpeakingParticipants hook returns the only the active speakers of all participants.\n *\n * @public\n */\nexport function useSpeakingParticipants() {\n  const room = useRoomContext();\n  const speakerObserver = React.useMemo(() => activeSpeakerObserver(room), [room]);\n  const activeSpeakers = useObservableState(speakerObserver, room.activeSpeakers);\n  return activeSpeakers;\n}\n","import { setupStartAudio } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @alpha */\nexport interface UseStartAudioProps {\n  room?: Room;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useStatAudio` hook returns an object with a boolean `canPlayAudio` flag\n * that indicates whether audio playback is allowed in the current context,\n * as well as a `startAudio` function that can be called in a button `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useStartAudio({ room, props }: UseStartAudioProps) {\n  const roomEnsured = useEnsureRoom(room);\n  const { className, roomAudioPlaybackAllowedObservable, handleStartAudioPlayback } = React.useMemo(\n    () => setupStartAudio(),\n    [],\n  );\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured, roomAudioPlaybackAllowedObservable],\n  );\n  const { canPlayAudio } = useObservableState(observable, { canPlayAudio: false });\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: () => {\n          handleStartAudioPlayback(roomEnsured);\n        },\n        style: { display: canPlayAudio ? 'none' : 'block' },\n      }),\n    [props, className, canPlayAudio, handleStartAudioPlayback, roomEnsured],\n  );\n\n  return { mergedProps, canPlayAudio };\n}\n","import * as React from 'react';\n\n/**\n * @alpha\n */\nexport type UseSwipeOptions = {\n  minSwipeDistance?: number;\n  onLeftSwipe?: () => void;\n  onRightSwipe?: () => void;\n};\n\n/**\n * Simple implementation to detect horizontal swipe actions.\n * Accepts callbacks for on right and left swipes.\n * @example\n * ```tsx\n *  <div\n      onTouchStart={onTouchStart}\n      onTouchMove={onTouchMove}\n      onTouchEnd={onTouchEnd}\n    >\n * ```\n * @alpha\n */\nexport function useSwipe(element: React.RefObject<HTMLElement>, options: UseSwipeOptions = {}) {\n  const touchStart = React.useRef<number | null>(null);\n  const touchEnd = React.useRef<number | null>(null);\n\n  // The required distance between touchStart and touchEnd to be detected as a swipe.\n  const minSwipeDistance = options.minSwipeDistance ?? 50;\n\n  const onTouchStart = (event: TouchEvent) => {\n    touchEnd.current = null; // Otherwise the swipe is fired even with usual touch events.\n    touchStart.current = event.targetTouches[0].clientX;\n  };\n\n  const onTouchMove = (event: TouchEvent) => {\n    touchEnd.current = event.targetTouches[0].clientX;\n  };\n\n  const onTouchEnd = React.useCallback(() => {\n    if (!touchStart.current || !touchEnd.current) {\n      return;\n    }\n    const distance = touchStart.current - touchEnd.current;\n    const isLeftSwipe = distance > minSwipeDistance;\n    const isRightSwipe = distance < -minSwipeDistance;\n\n    if (isLeftSwipe && options.onLeftSwipe) options.onLeftSwipe();\n    if (isRightSwipe && options.onRightSwipe) options.onRightSwipe();\n  }, [minSwipeDistance, options]);\n\n  React.useEffect(() => {\n    const elementCopy = element.current;\n    if (elementCopy) {\n      elementCopy.addEventListener('touchstart', onTouchStart, { passive: true });\n      elementCopy.addEventListener('touchmove', onTouchMove, { passive: true });\n      elementCopy.addEventListener('touchend', onTouchEnd, { passive: true });\n    }\n    return () => {\n      if (elementCopy) {\n        elementCopy.removeEventListener('touchstart', onTouchStart);\n        elementCopy.removeEventListener('touchmove', onTouchMove);\n        elementCopy.removeEventListener('touchend', onTouchEnd);\n      }\n    };\n  }, [element, onTouchEnd]);\n}\n","import { setupChatToggle } from '@livekit/components-core';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseChatToggleProps {\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/** @public */\nexport function useChatToggle({ props }: UseChatToggleProps) {\n  const { dispatch, state } = useLayoutContext().widget;\n  const { className } = React.useMemo(() => setupChatToggle(), []);\n\n  const mergedProps = React.useMemo(() => {\n    return mergeProps(props, {\n      className,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'toggle_chat' });\n      },\n      'aria-pressed': state?.showChat ? 'true' : 'false',\n      'data-lk-unread-msgs': state\n        ? state.unreadMessages < 10\n          ? state.unreadMessages.toFixed(0)\n          : '9+'\n        : '0',\n    });\n  }, [props, className, dispatch, state]);\n\n  return { mergedProps };\n}\n","import { log } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UserInfo {\n  identity?: string;\n  name?: string;\n  metadata?: string;\n}\n\n/** @public */\nexport interface UseTokenOptions {\n  userInfo?: UserInfo;\n}\n\n/** @public */\nexport function useToken(\n  tokenEndpoint: string | undefined,\n  roomName: string,\n  options: UseTokenOptions = {},\n) {\n  const [token, setToken] = React.useState<string | undefined>(undefined);\n\n  React.useEffect(() => {\n    if (tokenEndpoint === undefined) {\n      throw Error('token endpoint needs to be defined');\n    }\n    if (options.userInfo?.identity === undefined) {\n      return;\n    }\n    const tokenFetcher = async () => {\n      log.debug('fetching token');\n      const params = new URLSearchParams({ ...options.userInfo, roomName });\n      const res = await fetch(`${tokenEndpoint}?${params.toString()}`);\n      const { accessToken } = await res.json();\n      setToken(accessToken);\n    };\n    tokenFetcher();\n  }, [tokenEndpoint, roomName, options]);\n  return token;\n}\n","import { setupTrackMutedIndicator } from '@livekit/components-core';\nimport type { Participant, Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseTrackMutedIndicatorOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useTrackMutedIndicator(\n  source: Track.Source,\n  options: UseTrackMutedIndicatorOptions = {},\n) {\n  const p = useEnsureParticipant(options.participant);\n  const { className, mediaMutedObserver } = React.useMemo(\n    () => setupTrackMutedIndicator(p, source),\n    [p, source],\n  );\n\n  const isMuted = useObservableState(mediaMutedObserver, !!p.getTrack(source)?.isMuted);\n\n  return { isMuted, className };\n}\n","import type { ToggleSource } from '@livekit/components-core';\nimport { setupMediaToggle, setupManualToggle, log } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { TrackToggleProps } from '../components';\nimport { useMaybeRoomContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseTrackToggleProps<T extends ToggleSource>\n  extends Omit<TrackToggleProps<T>, 'showIcon'> {}\n\n/** @public */\nexport function useTrackToggle<T extends ToggleSource>({\n  source,\n  onChange,\n  initialState,\n  captureOptions,\n  ...rest\n}: UseTrackToggleProps<T>) {\n  const room = useMaybeRoomContext();\n  const track = room?.localParticipant?.getTrack(source);\n\n  const { toggle, className, pendingObserver, enabledObserver } = React.useMemo(\n    () => (room ? setupMediaToggle<T>(source, room, captureOptions) : setupManualToggle()),\n    [room, source, JSON.stringify(captureOptions)],\n  );\n\n  const pending = useObservableState(pendingObserver, false);\n  const enabled = useObservableState(enabledObserver, initialState ?? !!track?.isEnabled);\n\n  React.useEffect(() => {\n    onChange?.(enabled);\n  }, [enabled, onChange]);\n\n  React.useEffect(() => {\n    if (initialState !== undefined) {\n      log.debug('forcing initial toggle state', source, initialState);\n      toggle(initialState);\n    }\n    // only execute once at the beginning\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const newProps = React.useMemo(() => mergeProps(rest, { className }), [rest, className]);\n\n  const clickHandler: React.MouseEventHandler<HTMLButtonElement> = React.useCallback(\n    (evt) => {\n      toggle();\n      rest.onClick?.(evt);\n    },\n    [rest, toggle],\n  );\n\n  return {\n    toggle,\n    enabled,\n    pending,\n    track,\n    buttonProps: {\n      ...newProps,\n      'aria-pressed': enabled,\n      'data-lk-source': source,\n      'data-lk-enabled': enabled,\n      disabled: pending,\n      onClick: clickHandler,\n    } as React.ButtonHTMLAttributes<HTMLButtonElement>,\n  };\n}\n","import type {\n  SourcesArray,\n  TrackReference,\n  TrackReferenceOrPlaceholder,\n  TrackSourceWithOptions,\n  TrackReferencePlaceholder,\n} from '@livekit/components-core';\nimport {\n  isSourcesWithOptions,\n  isSourceWitOptions,\n  log,\n  trackReferencesObservable,\n} from '@livekit/components-core';\nimport type { Participant, Room, RoomEvent } from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport type UseTracksOptions = {\n  updateOnlyOn?: RoomEvent[];\n  onlySubscribed?: boolean;\n  room?: Room;\n};\n\n/** @public */\nexport type UseTracksHookReturnType<T> = T extends Track.Source[]\n  ? TrackReference[]\n  : T extends TrackSourceWithOptions[]\n  ? TrackReferenceOrPlaceholder[]\n  : never;\n\n/**\n * The `useTracks` hook returns an array of `TrackReference` or `TrackReferenceOrPlaceholder` depending on the provided `sources` property.\n * If only subscribed tracks are desired, set the `onlySubscribed` property to `true`.\n * @example\n * ```ts\n * // Return all camera track publications.\n * const trackReferences: TrackReference[] = useTracks([Track.Source.Camera])\n * ```\n * @example\n * ```ts\n * // Return all subscribed camera tracks as well as placeholders for\n * // participants without a camera subscription.\n * const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] = useTracks([{source: Track.Source.Camera, withPlaceholder: true}])\n * ```\n * @public\n */\nexport function useTracks<T extends SourcesArray = Track.Source[]>(\n  sources: T = [\n    Track.Source.Camera,\n    Track.Source.Microphone,\n    Track.Source.ScreenShare,\n    Track.Source.ScreenShareAudio,\n    Track.Source.Unknown,\n  ] as T,\n  options: UseTracksOptions = {},\n): UseTracksHookReturnType<T> {\n  const room = useEnsureRoom(options.room);\n  const [trackReferences, setTrackReferences] = React.useState<TrackReference[]>([]);\n  const [participants, setParticipants] = React.useState<Participant[]>([]);\n\n  const sources_ = React.useMemo(() => {\n    return sources.map((s) => (isSourceWitOptions(s) ? s.source : s));\n  }, [JSON.stringify(sources)]);\n\n  React.useEffect(() => {\n    const subscription = trackReferencesObservable(room, sources_, {\n      additionalRoomEvents: options.updateOnlyOn,\n      onlySubscribed: options.onlySubscribed,\n    }).subscribe(({ trackReferences, participants }) => {\n      log.debug('setting track bundles', trackReferences, participants);\n      setTrackReferences(trackReferences);\n      setParticipants(participants);\n    });\n    return () => subscription.unsubscribe();\n  }, [room, JSON.stringify(options.updateOnlyOn), JSON.stringify(sources)]);\n\n  const maybeTrackReferences = React.useMemo(() => {\n    if (isSourcesWithOptions(sources)) {\n      const requirePlaceholder = requiredPlaceholders(sources, participants);\n      const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] =\n        Array.from(trackReferences);\n      participants.forEach((participant) => {\n        if (requirePlaceholder.has(participant.identity)) {\n          const sourcesToAddPlaceholder = requirePlaceholder.get(participant.identity) ?? [];\n          sourcesToAddPlaceholder.forEach((placeholderSource) => {\n            if (\n              trackReferences.find(\n                ({ participant: p, publication }) =>\n                  participant.identity === p.identity && publication.source === placeholderSource,\n              )\n            ) {\n              return;\n            }\n            log.debug(\n              `Add ${placeholderSource} placeholder for participant ${participant.identity}.`,\n            );\n            const placeholder: TrackReferencePlaceholder = {\n              participant,\n              source: placeholderSource,\n            };\n            trackReferencesWithPlaceholders.push(placeholder);\n          });\n        }\n      });\n      return trackReferencesWithPlaceholders;\n    } else {\n      return trackReferences;\n    }\n  }, [trackReferences, participants, sources]);\n\n  return maybeTrackReferences as UseTracksHookReturnType<T>;\n}\n\nfunction difference<T>(setA: Set<T>, setB: Set<T>): Set<T> {\n  const _difference = new Set(setA);\n  for (const elem of setB) {\n    _difference.delete(elem);\n  }\n  return _difference;\n}\n\nexport function requiredPlaceholders<T extends SourcesArray>(\n  sources: T,\n  participants: Participant[],\n): Map<Participant['identity'], Track.Source[]> {\n  const placeholderMap = new Map<Participant['identity'], Track.Source[]>();\n  if (isSourcesWithOptions(sources)) {\n    const sourcesThatNeedPlaceholder = sources\n      .filter((sourceWithOption) => sourceWithOption.withPlaceholder)\n      .map((sourceWithOption) => sourceWithOption.source);\n\n    participants.forEach((participant) => {\n      const sourcesOfSubscribedTracks = participant\n        .getTracks()\n        .map((pub) => pub.track?.source)\n        .filter((trackSource): trackSource is Track.Source => trackSource !== undefined);\n      const placeholderNeededForThisParticipant = Array.from(\n        difference(new Set(sourcesThatNeedPlaceholder), new Set(sourcesOfSubscribedTracks)),\n      );\n      // If the participant needs placeholder add it to the placeholder map.\n      if (placeholderNeededForThisParticipant.length > 0) {\n        placeholderMap.set(participant.identity, placeholderNeededForThisParticipant);\n      }\n    });\n  }\n  return placeholderMap;\n}\n"],"mappings":"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","names":["React","React","React","React","React","React","React","React","React","React","React","React","React","React","React","ConnectionState","React","ConnectionState","React","React","log","React","log","React","createMediaDeviceObserver","log","React","React","mergeProps","publication","log","mergeProps","React","log","React","React","React","participantPermissionObserver","participantPermissionObserver","React","React","React","React","React","React","React","React","roomAudioPlaybackAllowedObservable","React","React","log","React","log","React","log","React","_a","log","log","Track","React","Track","trackReferences","participants","log"]}